
### Content

---

## 매일 메일 질문 답변하기

> 💡 ****Record를 DTO로 사용하는 이유가 뭔가요?****

Record는 Java 16에서 정식 출시한 불변성을 기본으로 하는 클래스이다.


**특징**

- **기존의 클래스와 달리, 모든 필드가 final 키워드로 선언되며 객체 생성 후 변경할 수 없다.**

- **필드 선언 만으로 자동으로 생성자, getter, equals(), hashCode(), toString() 등의 메서드를 생성한다.**
  - → 보일러 플레이트 코드를 줄일 수 있음



Record는 데이터를 캡슐화하는 역할을 하는데 이를 통해 DTO, VO 등 다양한 용도로 사용할 수 있다.
DTO : 계층 간 데이터 전송을 목적으로 하는 객체

VO : 도메인 모델 내에서 특정 값을 표현하는 객체



Record와 VO의 공통점

- **객체의 상태가 변경되지 않음을 보장함**

- **데이터를 캡슐화하여 표현하는 것에 포커스**

- **VO는 값 기반의 동등성을 갖고, Record의 경우에도 동일한 필드 값을 가지면 동일한 객체로 간주됨**


VO는 도메인 모델 내에서 특정 개념을 표현하고, 도메인 로직과 밀접한 연관을 가짐

→ 비즈니스 로직이나 규칙을 가질 수 있음

(Record는 단순 데이터 캡슐화 후 전달하는데 의미를 가짐)


**그러므로 Record는 VO를 구현하는데 적합하나. VO의 모든 특성을 완벽히 대체하진 않음**


**Record의 한계**

- **extends를 사용하여 다른 클래스를 상속할 수 없음**

- **필드가 final로 선언되기 때문에 확장에 어려움이 있음**

- **데이터를 전달하려는 목적으로 설계되었기 때문에 비즈니스 로직을 담기 적절하지 않음**

- **Java 14, Java 16 이전 버전에서 호환이 불가능**


> 💡 ****useEffect가 호출되는 시점에 대해 설명해 주세요.****

컴포넌트의 특정 시점에 자동으로 호출되는 훅으로 마운트, 업데이트, 언마운트 시점에 호출된다.


1. **컴포넌트가 마운트 될 때 (처음 렌더링 후)**
  - 이 때 데이터 초기화, 외부 API 호출, 구독 설정 등의 작업을 실행할 수 있음 (초기 작업)


1. **의존성 배열에 지정된 값이 변경될 때**
  - 특정 상태나 props가 변경될 때마다 필요한 동작을 수행 (변화에 따라 동적으로 실행)

  - → 의존성 배열을 넘기지 않을 경우에는 매 렌더링마다 호출


1. **컴포넌트가 언마운트될 때**
  - 정리 함수를 이용하여 이벤트 리스너 제거, 타이머 해제, 구독 취소 등의 작업 수행



### **TIL**

---


> 💡 **TIL 작성**

